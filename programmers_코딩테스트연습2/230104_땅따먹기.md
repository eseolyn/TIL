20230104 Wed  
20230611  
프로그래머스  
코딩테스트 문제 Level.2  

땅따먹기
---
문제 설명  
땅따먹기 게임을 하려고 합니다. 땅따먹기 게임의 땅(land)은 총 N행 4열로 이루어져 있고, 모든 칸에는 점수가 쓰여 있습니다.  
1행부터 땅을 밟으며 한 행씩 내려올 때, 각 행의 4칸 중 한 칸만 밟으면서 내려와야 합니다.  
단, 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙이 있습니다.  

예를 들면,  

| 1 | 2 | 3 | 5 |

| 5 | 6 | 7 | 8 |

| 4 | 3 | 2 | 1 |

로 땅이 주어졌다면, 1행에서 네번째 칸 (5)를 밟았으면, 2행의 네번째 칸 (8)은 밟을 수 없습니다.  

마지막 행까지 모두 내려왔을 때, 얻을 수 있는 점수의 최대값을 return하는 solution 함수를 완성해 주세요.  
위 예의 경우, 1행의 네번째 칸 (5), 2행의 세번째 칸 (7), 3행의 첫번째 칸 (4) 땅을 밟아 16점이 최고점이 되므로 16을 return 하면 됩니다.  

제한사항  
- 행의 개수 N : 100,000 이하의 자연수
- 열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다.
- 점수 : 100 이하의 자연수

입출력 예
land	| answer
--|--
[[1,2,3,5],[5,6,7,8],[4,3,2,1]]	| 16

#### 나의 풀이  
열이 4개 뿐이기에 할 수 있는 코드  
왜 현재값[0<i]에서 전 행(누적값)의 최대값을 더하는건 되는데  
현재값[i] (누적값)에서 다음행의 최대값를 더하는건 안될까 => 탐욕법?  

탐욕법, DFS, BFS는 맞지 않음  
바로 다음행만 고려한다면 결과적으로 최선의 선택을 하지 못할 수 있다.  
따라서 현재행에 전 행들의 최선의 값이 담긴 누적값을 더하는 방식을 써야 한다.   
예시)  
`[[4, 3, 2, 1], [2, 2, 2, 1], [6, 6, 6, 4], [8, 7, 6, 5]] // 20`  
`[[0,1,1,10], [0,1,1,100]] // 101`  


다음행의 최댓값 더하기 = 문제 순서 그대로 = 탐욕법?  
[4, 3, 2, 1]   
[6, 5, 4, 3]   
[12,11,10,9]   
[19,19,18,17]  
  
전 행의 최댓값 더하기 = DP Top-down?  
[4, 3, 2, 1]  
[5, 6, 6, 5]  
[12,12,12,10]  
[20,19,18,17]  
```jsx
function solution(land) {
    for(let i=1; i<land.length; i++) {
        land[i][0] += Math.max(
            land[i-1][1],
            land[i-1][2],
            land[i-1][3],
        );
        land[i][1] += Math.max(
            land[i-1][0],
            land[i-1][2],
            land[i-1][3],
        );
        land[i][2] += Math.max(
            land[i-1][0],
            land[i-1][1],
            land[i-1][3],
        );
        land[i][3] += Math.max(
            land[i-1][0],
            land[i-1][1],
            land[i-1][2],
        );
    }
    
    return Math.max(...land[land.length-1]);
}
```

#### 다른 사람의 풀이
```jsx
function solution(land) {
    var answer = 0;

    return Math.max(...land.reduce((a, c) => {
        return [
            c[0] + Math.max(a[1], a[2], a[3]),  
            c[1] + Math.max(a[0], a[2], a[3]),
            c[2] + Math.max(a[0], a[1], a[3]),
            c[3] + Math.max(a[0], a[1], a[2]),
        ];
    }, [0, 0, 0, 0]));
}
```

#### 자료구조 : 동적계획법(dynamic programming)
참고 해설:
https://school.programmers.co.kr/learn/courses/18/lessons/846  
https://shanepark.tistory.com/183
